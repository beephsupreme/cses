use crate::prelude::*;
use crate::utils::validate_range;

/// The problem is described in detail at https://cses.fi/problemset/task/1068
/// Starts with a positive integer n and constructs a sequence of numbers using the following algorithm:
/// - If n is even, divide it by 2. Otherwise, multiply it by 3 and add 1.
///  - Continue this process until n becomes 1.
/// ## Parameters
/// - n: u64 - a positive integer n such that 1 ≤ n ≤ 1000000.
/// ## Returns
/// - A vector of u64 containing the sequence of numbers generated by the algorithm or an error.
/// ## Performance
/// - The time complexity of this solution is O(n).
/// - The space complexity of this solution is O(n) because the vector is preallocated for n_max elements.
pub fn weird_algorithm(mut n: u64) -> Vec<u64> {
    let mut v: Vec<u64> = Vec::with_capacity(4096);
    loop {
        v.push(n);
        if n == 1 {
            break;
        }
        if n % 2 == 0 {
            n /= 2;
        } else {
            n = 3 * n + 1;
        }
    }
    v
}

/// Validates the input for the weird_algorithm function as follows:
/// * n must be in the range 1 ≤ n ≤ 1_000_000.
pub fn validate_weird_algorithm_input(n: u64) -> Result<()> {
    let n_range = 1..=1_000_000;
    validate_range("n".into(), n, &n_range)?;
    Ok(())
}

#[cfg(test)]

mod tests {
    use super::*;

    #[test]
    fn test_weird_algorithm_edge_left() {
        let n: u64 = 1;
        let expected: Vec<u64> = vec![1];
        let result = weird_algorithm(n);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_weird_algorithm_mid() {
        let n: u64 = 23;
        let expected: Vec<u64> = vec![23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1];
        let result = weird_algorithm(n);
        assert_eq!(result, expected);
    }

    #[test]
    fn tesst_weird_algorithm_edge_right() {
        let n: u64 = 1000000;
        let expected: Vec<u64> = vec![
            1000000, 500000, 250000, 125000, 62500, 31250, 15625, 46876, 23438, 11719, 35158,
            17579, 52738, 26369, 79108, 39554, 19777, 59332, 29666, 14833, 44500, 22250, 11125,
            33376, 16688, 8344, 4172, 2086, 1043, 3130, 1565, 4696, 2348, 1174, 587, 1762, 881,
            2644, 1322, 661, 1984, 992, 496, 248, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161,
            484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350,
            175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754,
            377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238,
            1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232,
            4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92,
            46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1,
        ];
        let result = weird_algorithm(n);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_validate_weird_algorithm_input_small() {
        let n: u64 = 0;
        let result = validate_weird_algorithm_input(n);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_weird_algorithm_input_large() {
        let n: u64 = 1000001;
        let result = validate_weird_algorithm_input(n);
        assert!(result.is_err());
    }
}
