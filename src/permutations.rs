use crate::prelude::*;
use crate::utils::validate_range;

/// The permutations function is detsailed at https://cses.fi/problemset/task/1070
/// A permutation of integers 1,2,…,n is called beautiful if there are no adjacent elements whose difference is 1.
/// ## Parameters
/// - n: u64 - a positive integer n such that 1 ≤ n ≤ 1000000.
/// ## Returns
/// - A vector of u64 containing the sequence of numbers generated by the algorithm or an error.
/// ## Performance
/// - The time complexity of this solution is O(n).
/// - The space complexity of this solution is O(n) because the values are stored ein a vector.
pub fn permutations(n: u64) -> Option<Vec<u64>> {
    let mut v: Vec<u64> = Vec::new();
    match n {
        1 => v.push(1),
        0 | 2 | 3 => return None,
        _ => {
            let half = n / 2;
            for i in 0..half {
                v.push(2 * i + 2);
            }
            for i in 0..n - half {
                v.push(2 * i + 1);
            }
        }
    }
    Some(v)
}

/// Validates the input for the Permutations function as follows:
/// * n must be in the range 1 ≤ n ≤ 1_000_000.
pub fn validate_permutations_input(n: u64) -> Result<()> {
    let n_range = 1..=1_000_000;
    validate_range("n".into(), n, &n_range)?;
    Ok(())
}

#[cfg(test)]

mod tests {
    use super::*;

    #[test]
    fn test_permutations_left() {
        let n: u64 = 1;
        let expected: Vec<u64> = vec![1];
        let result = permutations(n);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_permutations_mid() {
        let n: u64 = 23;
        let expected: Vec<u64> = vec![23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1];
        let result = permutations(n);
        assert_eq!(result, expected);
    }

    #[test]
    fn tesst_permutations_right() {
        let n: u64 = 1000000;
        let expected: Vec<u64> = vec![
            1000000, 500000, 250000, 125000, 62500, 31250, 15625, 46876, 23438, 11719, 35158,
            17579, 52738, 26369, 79108, 39554, 19777, 59332, 29666, 14833, 44500, 22250, 11125,
            33376, 16688, 8344, 4172, 2086, 1043, 3130, 1565, 4696, 2348, 1174, 587, 1762, 881,
            2644, 1322, 661, 1984, 992, 496, 248, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161,
            484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350,
            175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754,
            377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238,
            1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232,
            4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92,
            46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1,
        ];
        let result = permutations(n);
        assert_eq!(result, expected);
    }

    #[test]
    fn test_validate_permutations_input_small() {
        let n: u64 = 0;
        let result = validate_permutations_input(n);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_permutations_input_good() {
        let n: u64 = 0;
        let result = validate_permutations_input(n);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_permutations_large() {
        let n: u64 = 1000001;
        let result = validate_permutations_input(n);
        assert!(result.is_err());
    }
}
