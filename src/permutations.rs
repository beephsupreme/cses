use crate::prelude::*;
use crate::utils::validate_range;

/// The permutations function is detailed at https://cses.fi/problemset/task/1070\
/// A permutation of integers `1,2,…,n` is called beautiful if there are no adjacent elements whose difference is 1.
/// ## Parameters
/// - `n: u64` - a positive integer n such that 1 ≤ n ≤ 1e6.
/// ## Returns
/// - An Option variable containing either a `Vec<u64>` containing the sequence of numbers generated by the algorithm or `None` which indicates NO SOLUTION.
/// ## Performance
/// - The time complexity of this solution is O(n).
/// - The space complexity of this solution is O(n) because the values are stored in a vector.
pub fn permutations(n: u64) -> Option<Vec<u64>> {
    match n {
        1 => Some(vec![1]),
        0 | 2 | 3 => None,
        _ => {
            let mut v: Vec<u64> = Vec::with_capacity(n as usize);
            let half = n / 2;
            for i in 0..half {
                v.push(2 * i + 2);
            }
            for i in 0..n - half {
                v.push(2 * i + 1);
            }
            Some(v)
        }
    }
}
/// Validates the input for the `permutations` function.
/// * n must be in the range 1 ≤ n ≤ 1e6 or an LibraryError::OutOfRange error will be returned.
pub fn validate_permutations_input(n: u64) -> Result<()> {
    let n_range = 1..=1_000_000;
    validate_range("n".into(), n, &n_range)?;
    Ok(())
}

#[cfg(test)]

mod tests {
    use super::*;

    #[test]
    fn test_permutations_left() {
        let n: u64 = 1;
        let expected: Vec<u64> = vec![1];
        let result = permutations(n).unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn test_permutations_mid() {
        let n: u64 = 5;
        let expected: Vec<u64> = vec![2, 4, 1, 3, 5];
        let result = permutations(n).unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn test_permutations_right() {
        let n: u64 = 1000000;
        let mut expected = (1..=n).collect::<Vec<u64>>();
        let (even, odd): (Vec<u64>, Vec<u64>) = expected.iter().partition(|&x| x % 2 == 0);
        expected = even.iter().chain(odd.iter()).copied().collect();
        let result = permutations(n).unwrap();
        assert_eq!(result, expected);
    }

    #[test]
    fn test_validate_permutations_input_small() {
        let n: u64 = 0;
        let result = validate_permutations_input(n);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_permutations_input_good() {
        let n: u64 = 0;
        let result = validate_permutations_input(n);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_permutations_large() {
        let n: u64 = 1000001;
        let result = validate_permutations_input(n);
        assert!(result.is_err());
    }
}
